---
import Navbar from "./Navbar.astro";
import Footer from "./Footer.astro";

export interface Props {
  title: string;
}

const { title } = Astro.props;
---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width" />
    <meta name="generator" content={Astro.generator} />
    <meta
      name="description"
      content="alchemistsCo - Full-service marketing agency specializing in web development, media buying, and content creation. Transform your digital presence today."
    />
    <title>AlchemistsCo - {title}</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:wght@200;300;400;500;600;700;800&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="/style/custom.css" />
  </head>
  <body class="overflow-hidden overflow-y-auto bg-body">
    <Navbar />
    <slot />
    <Footer />
  </body>
  <script>
    // Force light mode - always remove dark class
    document.documentElement.classList.remove("dark");
    localStorage.setItem("theme", "light");

    // DISABLED: Theme switching functionality (kept for future use if needed)
    // Uncomment below to re-enable dark mode switching
    /*
    detectSystemTheme();

    const switchTheme = document.querySelector(
      "[data-switch-theme]"
    ) as HTMLButtonElement;
    if (switchTheme) {
      switchTheme.addEventListener("click", (e) => {
        e.preventDefault();
        changeThemeManually();
      });
    }

    function changeThemeManually() {
      const localAppTheme = localStorage.getItem("theme");
      // Whenever the user explicitly chooses dark mode, previously it was light mode
      if (localAppTheme === "light") {
        changeThemeToDark();
      }
      // Whenever the user explicitly chooses light mode, previously it was dark mode
      if (localAppTheme === "dark") {
        changeThemeToLight();
      }
      if (!localAppTheme) {
        console.log("previously it was not set");
        // Whenever the user explicitly chooses to respect the OS preference
        detectSystemTheme(true);
      }
    }

    function detectSystemTheme(manual = false) {
      if (
        localStorage.getItem("theme") === "dark" ||
        (!("theme" in localStorage) &&
          window.matchMedia("(prefers-color-scheme: dark)").matches)
      ) {
        document.documentElement.classList.add("dark");
        if (manual) localStorage.setItem("theme", "dark");
      } else {
        document.documentElement.classList.remove("dark");
        if (manual) localStorage.setItem("theme", "light");
      }
    }

    function changeThemeToDark() {
      localStorage.setItem("theme", "dark");
      document.documentElement.classList.add("dark");
    }

    function changeThemeToLight() {
      localStorage.setItem("theme", "light");
      document.documentElement.classList.remove("dark");
    }
    */
  </script>
  <script>
    const toggleMenu = document.querySelector(
      "[data-toggle-nav]",
    ) as HTMLButtonElement;
    const navbar = document.querySelector("[data-navbar]") as HTMLDivElement;
    const overlayNav = document.querySelector(
      "[data-nav-overlay]",
    ) as HTMLDivElement;
    if (toggleMenu) {
      toggleMenu.addEventListener("click", (e) => {
        e.preventDefault();
        if (toggleMenu.getAttribute("data-open-nav") === "false") {
          toggleMenu.setAttribute("data-open-nav", "true");
          overlayNav.setAttribute("data-is-visible", "true");
          document.body.classList.add("!overflow-y-hidden");
          navbar.style.height = `${navbar.scrollHeight}px`;
        } else {
          toggleMenu.setAttribute("data-open-nav", "false");
          overlayNav.setAttribute("data-is-visible", "false");
          document.body.classList.remove("!overflow-y-hidden");
          navbar.style.height = "0px";
        }
      });

      navbar.addEventListener("click", () => {
        toggleMenu.setAttribute("data-open-nav", "false");
        overlayNav.setAttribute("data-is-visible", "false");
        document.body.classList.remove("!overflow-y-hidden");
        navbar.style.height = "0px";
      });

      overlayNav.addEventListener("click", () => {
        toggleMenu.setAttribute("data-open-nav", "false");
        overlayNav.setAttribute("data-is-visible", "false");
        document.body.classList.remove("!overflow-y-hidden");
        navbar.style.height = "0px";
      });
    }
  </script>
  <script>
    // Sticky header with blur on scroll
    const header = document.getElementById("navbar");
    let lastScroll = 0;

    function handleScroll() {
      const currentScroll = window.pageYOffset;

      if (currentScroll > 50) {
        header?.classList.add("scrolled");
      } else {
        header?.classList.remove("scrolled");
      }

      lastScroll = currentScroll;
    }

    window.addEventListener("scroll", handleScroll, { passive: true });
    handleScroll(); // Check on load

    // Scroll animations with Intersection Observer
    const observerOptions = {
      threshold: 0.1,
      rootMargin: "0px 0px -50px 0px",
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          entry.target.classList.add("visible");
          // Optionally unobserve after animation
          // observer.unobserve(entry.target);
        }
      });
    }, observerOptions);

    // Observe all elements with scroll animation classes
    document.addEventListener("DOMContentLoaded", () => {
      const animatedElements = document.querySelectorAll(
        ".scroll-fade-in, .scroll-slide-left, .scroll-slide-right, .scroll-scale, .scroll-scale-backdrop",
      );
      animatedElements.forEach((el) => observer.observe(el));
    });

    // Magnetic hover effect - DISABLED
    // Removed magnetic hover effect - was too distracting
    // Keeping function placeholder in case we want to add subtle effects later
    function initMagneticHover() {
      // Magnetic hover disabled - buttons now use simple CSS hover effects only
    }

    // Floating elements animation
    function initFloatingElements() {
      const floatingElements = document.querySelectorAll(
        ".float-animation, .float-animation-delayed",
      );
      floatingElements.forEach((el) => {
        el.classList.add("float-animation");
      });
    }

    // Card tilt effect on mouse move - faster and more responsive
    function initCardTilt() {
      const cards = document.querySelectorAll(
        '.card-tilt, [class*="Service"], [class*="card"]',
      );

      cards.forEach((card) => {
        (card as HTMLElement).style.transition = "transform 0.1s ease-out";

        card.addEventListener("mousemove", (e) => {
          const mouseEvent = e as MouseEvent;
          const rect = card.getBoundingClientRect();
          const x = mouseEvent.clientX - rect.left;
          const y = mouseEvent.clientY - rect.top;

          const centerX = rect.width / 2;
          const centerY = rect.height / 2;

          const rotateX = (y - centerY) / 6;
          const rotateY = (centerX - x) / 6;

          (card as HTMLElement).style.transform =
            `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale3d(1.02, 1.02, 1.02)`;
        });

        card.addEventListener("mouseleave", () => {
          (card as HTMLElement).style.transform =
            "perspective(1000px) rotateX(0) rotateY(0) scale3d(1, 1, 1)";
        });
      });
    }

    // Initialize all interactive features
    document.addEventListener("DOMContentLoaded", () => {
      initMagneticHover();
      initFloatingElements();
      initCardTilt();
    });
  </script>
</html>
